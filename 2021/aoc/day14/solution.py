from collections import Counter
from functools import cache
from pathlib import Path
from typing import Dict, List, Tuple, TypeAlias

from aoc.util import timing

Rules: TypeAlias = Dict[Tuple[str, str], str]


def most_minus_least(counter: Counter) -> int:
    counts = [item[1] for item in counter.most_common()]
    return counts[0] - counts[-1]


def part1(template: str, rules: Rules, steps: int = 10) -> int:
    """Simulates steps of the polymerization process to get an answer."""
    polymer: List[str] = list(template)
    for step in range(steps):
        print(f"Step: {step}")
        new_polymer = [polymer[0]]
        for a, b in zip(polymer, polymer[1:]):
            if c := rules.get((a, b)):
                new_polymer.append(c)
            new_polymer.append(b)
        polymer = new_polymer

    return most_minus_least(Counter(polymer))


def part2(template: str, rules: Rules, steps: int = 40) -> int:
    """Uses a cache to avoid unnecessary recomputation to get an answer."""

    @cache
    def char_counts(a: str, b: str, steps_remaining: int) -> Counter:
        """Returns a counter counting the chars generated by f'{a}{b}'.

        The steps_remaining variable indicates how many steps of the process
        should be considered when computing the counts of generated chars.
        The initial chars a and b are not counted by this function.
        """
        if steps_remaining == 0 or (a, b) not in rules:
            return Counter()

        mid = rules[(a, b)]
        counter = Counter((mid))
        counter.update(char_counts(a, mid, steps_remaining - 1))
        counter.update(char_counts(mid, b, steps_remaining - 1))
        return counter

    counter = Counter(template)
    for (a, b) in zip(template, template[1:]):
        counter.update(char_counts(a, b, steps))

    return most_minus_least(counter)


def main() -> None:
    rules = {}
    template = None
    with open(Path(__file__).parent.joinpath("input.txt")) as file:
        for line in file:
            if "->" in line:
                x, y = line.strip().split(" -> ")
                rules[tuple(x)] = y
            elif len(line.strip()):
                template = line.strip()

    with timing("Part 1"):
        solution = part1(template, rules)
    print(solution)

    with timing("Part 2"):
        solution = part2(template, rules)
    print(solution)


if __name__ == "__main__":
    main()
